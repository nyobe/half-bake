include ../cas.mk
include ../build_cache.mk

MAKEFLAGS += --no-builtin-rules

.DEFAULT_GOAL := all
.PHONY: all
all: bin/main bin/main2

$(shell mkdir -p bin)
GO = $(shell which go)

# simple example of content-based dependency tracking.
# cas_inputs creates a sentinel file that is only updated when the contents of the inputs change.
# you can test this by touching one of the inputs (main.go or lib.go) and observing that `make bin/main` does not rebuild.
# actually editing one of the input files will cause a rebuild.
#
# for correctness the toolchain should be included as part of the target inputs.
# cas_get_deps allows filtering the inputs based on a pattern, to allow extracting just the source file inputs.
bin/main: $(call cas_inputs,bin/main,$(GO) main.go lib.go)
	$(call cas_run,$(GO) build -o $@ $(call cas_get_deps,%.go))

# cas_run consumes the sentinel file generated by cas_inputs, and uses it as a cache key.
# on cache miss, it will run the given command and write the result into a content-addressed cache.
# on cache hit, it will restore the target from the cache instead of running the build command.
#
# you can see this in action when running `make all`: since main2 resolves to the same inputs as main,
# it will be pulled from the cache instead of built.
# this is a silly example, but in practice this avoids rebuilding artifacts when switching between branches.
bin/main2: $(call cas_inputs,bin/main2,$(GO) main.go lib.go)
	$(call cas_run,$(GO) build -o $@ $(call cas_get_deps,%.go))

# example of capturing a variable as part of the inputs
# the third argument of cas_inputs takes a list of env vars to consider as part of the inputs.
# here, we can see that the LDFLAGS are captured. Observe that changing the env var will force a rebuild.
LDFLAGS = -ldflags="-X 'main.Greeting=this-flag-is-captured-in-deps'"
bin/stamp: $(call cas_inputs,bin/stamp,$(GO) main.go lib.go,LDFLAGS)
	$(call cas_run,$(GO) build $(LDFLAGS) -o $@ $(call cas_get_deps,%.go))

# example of co-locating the hash file with a generated file
# if you run `make generated.txt` it should already be considered up to date because inputs still match the co-located hash file.
generated.txt: $(call cas_inputs_at,generated.txt,lib.go)
	# (pretend this is generating protobufs or mocks)
	cat $(call cas_get_deps,%.go) | tr '[:lower:]' '[:upper:]' > $@
